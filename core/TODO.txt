Items that need to be done:

--- RIGHT AWAY ---

* Shouldn't Attribute(String name, String prefix, String uri, String value)
  be Attribute(String name, String value, String prefix, String uri)?

* Consider Mike Jennings' proposal of two new methods on Element:
  public String getAttributeValue(String name, String default)
  public String getAttributeValue(String name, Namespace ns, String default)

* Change adapters to support creating a Document with a DOCTYPE, to allow 
  DOMBuilder to set the DOCTYPE on a built document

* Fix bug where addNamespaceDeclaration() doesn't check for conflicts with the
  same prefix already existing on the element or being the document's prefix
  already

* Shouldn't there be a removeNamespaceDeclaration(Namespace)?

* Shouldn't addNamespaceDeclaration() have a name to match
  getAdditionalNamespaces()

* Examine if it's worth doing an intern() on element and attribute names,
  of if it's too much to pay since SAX is likely doing it already
  http://www.megginson.com/SAX/Java/features.html
  Probably turn off SAX interning and do it ourselves?

* Figure out a way to set "standalone" in the decl, like doc.setStandalone().
  If necessary, that is.

* Consider enhancing SAXBuilder to use filters per
  http://www.megginson.com/SAX/Java/filters.html
  That would let someone remove surrounding whitespace and other fancy things.

* Consider visitor pattern (again, just to be sure)
  Use cases: count elements, count nodes, translate comments, remove PIs
  Would implement with option to visit depth or breadth first
  Maybe go crazy with pre-order, in-order, and post-order too :-)
  Methods would exist on Document and Element
  FYI, DOM's much overweight Traversal-Range spec is at
    http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/

* Make entity.clone() truly a deep copy.

* Use custom singly LinkedList to save memory.  (Jools has code.)

* Consider using a List of instance data so elements only use what they really
  need (saving attrib list, namespace list)

* Change PartialList to drive directly off backing list
  - Make sure PartialList doesn't let an elt be added as a child (or 
    grandchild, etc) of itself.  See elt.addContent() logic that walks 
    ancestry.
  - Have PartialList sanity check new object types as legal.
  - Look at the issue that PartialList.listIterator() may return an Iterator
    that doesn't have logic to change the backing List and sanity check the
    change.  See post by "Chris Hamersley" <chris.hamersley@xmlglobal.com>
    31 Aug 2000.  Also a follow-on by "Peter V. Gadjokov" <pvg@c-c-s.com> 
    27 Sep 2000 and a test case by "Travers Waker" <traversw@innoforge.co.za>
    27 Sep 2000.

* Straighten up the Entity API, bringing its API in line with Element and
  supporting EntityReferences.

* Test SinglyLinkedList vs ArrayList for speed and memory consumption.
  (With OptimizeIt)

* Verify we get good error handling if someone passes null to any add/set
  method.

--- FOR JDOM 1.0 ---

* Investigate doc.getDescription() to let people add doc descriptions.  It's
  an idea from IBM's parser suggested by andyk.

* Create "build dist" for distribution
  Use fixcrlf in dist (instead of package as currently done)
  Probably include source with jdom.jar built

* Consider changing XMLOutputter to have more set methods like Enhydra's
  DOMFormatter.  Possible good ones:
   void setJavaEncoding(java.lang.String newJavaEncoding) 
                       Set the encoding using the Java encoding name.
   void setLineWidth(int width) 
                       Set the width at while long lines are split 
                       when indentation is enabled.
   void setPreserveSpace(boolean preserve) 
                       Set the default space-preservation flag.
   void setXmlEncoding(java.lang.String newXmlEncoding) 
                       Set the encoding using the XML encoding name.
   void setXmlEncoding(java.lang.String newJavaEncoding,
                       java.lang.String newXmlEncoding) 
                       Set both the XML and Java encodings.

* Figure out if there should be a public no-arg Document constructor to
  support building docs with more than just root elts.  Currently you have to
  use a trick of new Document(null).  Elliotte thinks we should go the 
  opposite way and disallow creating docs without roots, thus enforcing the
  rule that JDOM only creates well-formed docs and docs are well-formed from
  the beginning.  That makes sense to me, actually.  The builders can create a
  List and then at the end assign it as the doc's mixed content.  Wonder if we
  should have a Document(List) constructor?  Prob'ly not.

* Consider adding methods/logic to Verifier for all XML spec. constraints
  (Consider specifically a PCDATA check.  Downside is Elliotte says it 
   causes a 20% performance penalty on building docs.)
  Probably go with sanity checking input unless it adds significant time to
  a SAX build.

* Consider changing the Verifier method signatures to throw the
  IllegalXXXException directly instead of returning null on error,
  and let the caller pass the exception through

* Have Jools populate jdom-test

* Implement inline entities:
        <?xml version='1.0' ?>
        <!DOCTYPE mydtd[
        <!ENTITY nbsp '&#160;'>
        <!ENTITY aring '&#229;'>
        <!ENTITY auml '&#228;'>
        <!ENTITY ouml '&#246;'>
        <!ENTITY Aring '&#197;'>
        <!ENTITY Auml '&#196;'>
        <!ENTITY Ouml '&#214;'>]>

        <DOCUMENT>
                God forts&auml;ttning p&aring; det nya millenniet!
        </DOCUMENT>

* Consider SAXBuilder.setIgnoreingWhitespace() and similar
  Should save lots of memory.

* Writing a "Getting started" guide for newbies 
  (Tom Clements <clements@eng.sun.com>)

* Add JAXP 1.1 supporting classes when it's ready.  Design them to follow the
  JAXP model so they are usable without JAXP, and can be trivially made to
  work with JAXP.

* Make sure we have a plan for supporting obj serialization across current and
  future JDOM versions

* Perhaps have builder flags to indicate if surrounding whitespace (not just
  ignorable whitespace) should be trimmed, if entity refs should be expanded,
  if CDATA sections should be included, and if comment sections should be
  included.  All seem like reasonable customizations.

--- FOR JDOM 1.1 ---

* Add XPath support
  Much work being done by Michael Hinchey

* Figure out XPath interface, current best is this:
    List    XPath.getList(Element e, String xpath)  // or Document param
    Comment XPath.getComment(Element e, String xpath)
    Element XPath.getElement(Element e, String xpath)
    ProcIns XPath.getProcIns(Element e, String xpath)
    Entity  XPath.getEntity(Element e, String xpath)
    String  XPath.getText(Element e, String xpath)

* Eliminate string hardcoding.  Use resource bundles to allow for
  localization.

* Investigate a way to do in-memory validation.  First step is probably 
  to get an in-memory representation of a DTD as per
  http://xmlhack.com/read.php?item=626
  http://www.wutka.com/dtdparser.html
  http://lists.denveronline.net/lists/jdom-interest/2000-July/001431.html

--- UNTIED TO A JDOM VERSION ---

* Contribute the samples from Elliotte's XML DevCon talk to the samples/
  directory.  http://metalab.unc.edu/xml/slides/xmlsig/jdom/JDOM.html

* Add search for jdom.org using Google with site:www.jdom.org, imitating
  http://www.zope.org/SiteIndex/searchForm

* Fix it so check-in messages include diffs.  (jools@jools.org)  Use
  archive to create an accurate CHANGELOG.txt for what changed between betas.

* Add ElementLocator to contrib/ directory (from Alfred Lopez)

* Put www.jdom.org content under CVS

* Write a guide for contributors
    Follow Sun's coding guidelines, use 4-space (no tab) indents, no lines
    longer than 80 characters

* Look at putting XML files in the jdom.jar META-INF directory for things like
  version, credits, description, etc, then access/print the info using JDOM
  classes executed by a "java -jar jdom.jar" command.  
  See http://java.sun.com/docs/books/tutorial/jar/

* Add JDOM version info to the MANIFEST.MF so servlets and such can depend on
  it using http://java.sun.com/j2se/1.3/docs/guide/extensions/versioning.html

* Investigate including a library to convert XML data to instantiated Java
  objects, probably with an XML config file dictating how to do the mapping.
  See http://xmlhack.com/read.php?item=674 for something along these lines.

* Investigate adding Andy's library (jhunter)

* Verify JDOM is compliant with Infoset
  http://xmlhack.com/read.php?item=966

* Consider a builder for a read-only document.  It could "intern" objects to
  reduce memory consumption.  In fact, interning may be good for String
  objects regardless.

* Consider having the license be clear org.jdom is a protected namespace.

--- WILD IDEAS ---

* Figure out if there's a role for a Node interface.  It sounds easy but all 
  attempts so far have hit obstacles.

* Consider having element.getChild("foo") use the namespace of the invoked 
  element.  Currently is would be the default namespace.  With this new
  approach you'd pass null to use the default.  This would be more convenient,
  but the downside I see is that it would be inconsistent since 
  new Element("foo") would only create elements in the default namespace.

* Think about somewhat crazy idea of using more inheritance in JDOM to allow
  lightweight but not XML 1.0 complete implementations.  For example Element
  could have a superclass "CommonXMLElement" that supported only what Common 
  XML requires.  Builders could build such elements to be faster and lighter 
  than full elements -- perfect for things like reading config files.  Lots
  of difficulties with this design though.

* Look at Xerces parser features (http://apache.org/xml/features/dom) for
  ideas on things that may be needed.
  http://xml.apache.org/xerces-j/features.html

* Create a JDOM logo

* Create a Verifier lookup table as an int[256] growable to int[64K] where 
  bits in the returned value indicate that char's ability to be used for a
  task.  So "lookup[(int)'x'] & LETTER_MASK" tells us if it's a letter
  or not.

* Use new Ant regexp task for more efficient JDK 1.1 package renaming.

* Consider methods to return an item's XPath, suggested by 
    Mores Stanislav <stm@prosoft.sk>
  /** Return XPath of this node */ 
  public StringBuffer getXPath(); 
  /** Return XPath of this node relative to given context node. */ 
  public StringBuffer getRelativeXPath(Element ancestor);

