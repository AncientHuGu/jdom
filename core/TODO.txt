Items that need to be done:

--- RIGHT AWAY ---

* Determine if setMixedContent() should remain atomic on failure or not.

* Fix JDK 1.1 build issues introduced with the Manifest work. (Jools?)

* Straighten up the Entity API.  Have a builder flag on whether or not to 
  expand entities.  Have a default of expansion.  That produces a doc without 
  regard for entity sources.  If expansion is off, then populate the doc with 
  EntityRef nodes which hold the information about the entity but don't 
  contain its contents.  XMLOutputter will in the non-expanded case be able 
  to retain the original entity names and locations.  The reason not to do a 
  hybrid of keeping entities and expanding is that then what do you do if you 
  change the content within the "entity"?  You can't do anything because on 
  output you aren't writing the file that holds that content.  So either it's 
  this doc's content now, or it's held only as a ref.  Make sure DOMBuilder 
  and SAXBuilder work equivalently.  This means making an EntityRef class
  instead of Entity.  It should probably have a name, public ID, and system 
  ID per
  http://lists.denveronline.net/lists/jdom-interest/2000-September/002838.html.
  May also want to read:
  http://lists.denveronline.net/lists/jdom-interest/2000-September/002844.html.
  Also see:
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003540.html
  We may need to keep track of entity declarations coming in so that we can 
  map the name in startEntity(String) to the public ID and system ID.
  Give Entity a decent clone() method too.  And have its equals() be based on
  == because it's a node in the tree.

* Figure out if we by default do:
    public void ignorableWhitespace(char[] ch, int start, int length)
                             throws SAXException {
        characters(ch, start, length);
    }
  With a setIgnoringElementContentWhitespace(boolean) and 
  setIgnoringAllWhitespace(boolean) pair of methods.

* Make it so elt.getAdditionalNamespaces() returns a mutable list.
  This means we have to stop using EMPTY_LIST and need to sanity check 
  additions.

* Add to Javadocs @throws clauses for all runtime exceptions like 
  IllegalAddException

* Fix bug where DOMOutputter creates nodes with "" as their
  node.getNamespaceURI() even if the node is not in a namespace.
  http://lists.denveronline.net/lists/jdom-interest/2001-March/005117.html

* Remove hack requiring new Document(null).  The builders can create a
  List and then at the end assign it as the doc's mixed content.

* Fix minor XMLOutputter bug where pretty print (indented, newlines, trim
  text) prints an extra whitespace line between one closing element and 
  another.

* Implement the ability to output the same DOCTYPE as was input.  Store the
  internal DTD subset as a String variable in DocType.  This means we need 
  to reconstruct the String based on SAX events of the DTDHandler/DeclHandler.
  Or if reading from DOM then from the DOM DocumentType.
        <?xml version='1.0' ?>
        <!DOCTYPE mydtd[
        <!ENTITY nbsp '&#160;'>
        <!ENTITY aring '&#229;'>
        <!ENTITY auml '&#228;'>
        <!ENTITY ouml '&#246;'>
        <!ENTITY Aring '&#197;'>
        <!ENTITY Auml '&#196;'>
        <!ENTITY Ouml '&#214;'>]>
  (Harry Evans <hevans@elite.com> is also working on this.)

* Add parentage to DocType.

* Make DocType.equals() check for equivalency and not reference equality.

* Add notes that element content returned by List is ordered.

* Integrate element factories in SAXBuilder.  (Ken Helland)

* Make Namespace.equals() check based on URI.  The issue's been brought up
  again.  Historic info is in
  http://lists.denveronline.net/lists/jdom-interest/2000-August/subject.html
  First message in the thread is
  http://lists.denveronline.net/lists/jdom-interest/2000-August/002171.html
  MAKE SURE this doesn't break the factory model.

* Investigate ClassLoader.loadClass() instead of Class.forName() for those
  times when the classes aren't on the system classpath.  (Suggested by Alex
  Rosen)

* Change elt.addAttribute to elt.setAttribute(), doing an implicit replace if
  necessary.  Consider using LinkedHashMap from JPDA to preserve attrib order.
  It's not open source, so a List may be fine.  You don't generally have that
  many attributes.

* Change elt.setAttribute() to check for attributes with duplicate names & 
  namespaces.

* Fix bug where addNamespaceDeclaration() doesn't check for conflicts with the
  same prefix already existing on the element or being the element's own 
  prefix already

* Examine if it's worth doing an intern() on element and attribute names,
  or if it's too much to pay since SAX is likely doing it already
  http://www.megginson.com/SAX/Java/features.html
  Probably turn off SAX interning and do it ourselves?  Note commentary:
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003289.html

* Perhaps have builder flags to indicate if surrounding whitespace (not just
  ignorable whitespace) should be trimmed, if entity refs should be expanded,
  if CDATA sections should be included, and if comment sections should be
  included.  All seem like reasonable customizations.  The whitespace flag
  should respect xml:space.  It might use an XMLFilter to do the job.

* Investigate a custom singly LinkedList to save memory.  (Jools has code.)

* Change PartialList to drive directly off backing list.  Jools is working on
  this calling it FilterList.  See the temporary "work in progress" jdom-wip 
  module.
  - Make sure PartialList doesn't let an elt be added as a child (or 
    grandchild, etc) of itself.  See elt.addContent() logic that walks 
    ancestry.
  - Have PartialList sanity check new object types as legal.
  - Look at the issue that PartialList.listIterator() may return an Iterator
    that doesn't have logic to change the backing List and sanity check the
    change.  See post by "Chris Hamersley" <chris.hamersley@xmlglobal.com>
    31 Aug 2000.  Also a follow-on by "Peter V. Gadjokov" <pvg@c-c-s.com> 
    27 Sep 2000 and a test case by "Travers Waker" <traversw@innoforge.co.za>
    27 Sep 2000.

* Test SinglyLinkedList vs ArrayList for speed and memory consumption.
  (With OptimizeIt, Joe Bowbeer may lead this)

* Verify we get good error handling if someone passes null to any add/set
  method.

* Remove getSerializedForm() calls.  Move logic into XMLOutputter.

* Determine if DOMBuilder and DOMOutputter should transparently support DOM1.

* Look at where Namespace may need to be synchronized.  See
  http://lists.denveronline.net/lists/jdom-interest/2000-September/003009.html
  and follow-ups.

* Fix unconfirmed bug of unwanted line breaks occurring between tags.
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003241.html

* Fix issue where XMLOutputter has protected methods dependent on
  NamespaceStack, as pointed out by elharo:
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003538.html

* Look into having a flag to turn off DTD loading, since parsers often load
  the DTD even if validation is off.
  Xerces has a custom option: http://xml.apache.org/xerces-j/features.html
  Crimson doesn't, nor probably do others.  That makes it tricky.

* Figure out how to deal with XMLOutputter writing of special characters like
  &#160.  Should it char escape only chars unprintable in the current
  character set?  Or should there be a fancy API for selecting what's escaped?
  http://lists.denveronline.net/lists/jdom-interest/2001-February/004521.html

* Investigate the capabilities of David Megginson's XMLWriter at 
  http://www.megginson.com/Software/ as a way to output a document.
  More info: http://xmlhack.com/read.php?item=777

* Consider an XMLOutputter flag or feature to convert characters with well
  known named character entities to their named char entity form instead of
  numeric.

* See if there's a better name than getTextTrim() for a method that does
  internal whitespace collapsing in addition to trimming

* Change XMLOutputter.setTrimText(boolean) to setTextTrim(boolean) or whatever
  name the above resolves to

--- FOR JDOM 1.0 ---

* Expand class-level Javadocs.

* Use MIF Doclet to include javadoc output into MIF/Word/Frame/PDF file.
  http://java.sun.com/j2se/1.3/docs/tooldocs/javadoc/index.html
  http://java.sun.com/j2se/javadoc/mifdoclet/index.html (mifdoclet_C.zip)

* Create "build dist" for distribution
  Use fixcrlf in dist (instead of package as currently done)
  Probably include source with jdom.jar built

* Consider changing XMLOutputter to have more set methods like Enhydra's
  DOMFormatter.  Possible good ones:
   void setJavaEncoding(java.lang.String newJavaEncoding) 
                       Set the encoding using the Java encoding name.
   void setLineWidth(int width) 
                       Set the width at while long lines are split 
                       when indentation is enabled.
   void setPreserveSpace(boolean preserve) 
                       Set the default space-preservation flag.
   void setXmlEncoding(java.lang.String newXmlEncoding) 
                       Set the encoding using the XML encoding name.
   void setXmlEncoding(java.lang.String newJavaEncoding,
                       java.lang.String newXmlEncoding) 
                       Set both the XML and Java encodings.

* Consider adding methods/logic to Verifier for all XML spec. constraints
  (Consider specifically a PCDATA check.  Downside is Elliotte says it 
   causes a 20% performance penalty on building docs.)
  Probably go with sanity checking input unless it adds significant time to
  a SAX build.
  See http://lists.denveronline.net/lists/jdom-interest/2000-August/002088.html
  And http://lists.denveronline.net/lists/jdom-interest/2000-August/002102.html

* Consider changing the Verifier method signatures to throw the
  IllegalXXXException directly instead of returning null on error,
  and let the caller pass the exception through

* Have Jools populate jdom-test

* Consider SAXBuilder.setIgnoreingWhitespace() and similar
  Should save lots of memory.

* Make sure we have a plan for supporting obj serialization across current and
  future JDOM versions.  See "serialVersionUID" thread especially 
  Peter V. Gadjokov's remarks at
  http://lists.denveronline.net/lists/jdom-interest/2000-September/subject.html

* Performance optimize.  See following thread for test data.
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003418.html
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003472.html

* Figure out permanent home for JDOMSource and JDOMResult currently living in
  jdom-contrib.  Most likely options are org.jdom.transform or in JAXP.next.
  If org.jdom.transform that could be the home of a transform implementation.

* Consider visitor pattern (again, just to be sure)
  Use cases: count elements, count nodes, translate comments, remove PIs
  Would implement with option to visit depth or breadth first
  Maybe go crazy with pre-order, in-order, and post-order too :-)
  Methods would exist on Document and Element
  FYI, DOM's much overweight Traversal-Range spec is at
    http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/
  Joe Bowbeer has ideas at:
  http://lists.denveronline.net/lists/jdom-interest/2000-November/003610.html

--- FOR JDOM 1.1 ---

* Add XPath support
  Much work being done by Michael Hinchey

* Figure out XPath interface, current best is this:
    List    XPath.getList(Element e, String xpath)  // or Document param
    Comment XPath.getComment(Element e, String xpath)
    Element XPath.getElement(Element e, String xpath)
    ProcIns XPath.getProcIns(Element e, String xpath)
    Entity  XPath.getEntity(Element e, String xpath)
    String  XPath.getText(Element e, String xpath)

* Eliminate string hardcoding.  Use resource bundles to allow for
  localization.

* Investigate a way to do in-memory validation.  First step is probably 
  to get an in-memory representation of a DTD as per
  http://xmlhack.com/read.php?item=626
  http://www.wutka.com/dtdparser.html
  http://lists.denveronline.net/lists/jdom-interest/2000-July/001431.html
  http://lists.denveronline.net/lists/jdom-interest/2001-February/004661.html
  Maybe new DTDValidator(dtd).validate(doc);
  Then later new SchemaValidator(schema).validate(doc);
  Could instead do doc.validate(dtd/schema) but then we'd have to dynamically 
  switch between recognizing DTDs and the various schemas.
  The method would probably either throw InvalidDocumentException or might
  take an ErrorHandler-style interface implementation if there are non-fatal
  errors possible.
  It'd also be possible to have a programmatic verifier, that determined for
  example if an orderid="100" entry was valid against a database entry.

* Consider a listener interface so you could listen to doc changes.  
  (Probably after 1.1 honestly; this can be done through manual subclasses
  already.)  Some pertinent messages on this topic:
  http://lists.denveronline.net/lists/jdom-interest/2000-July/001586.html
  http://lists.denveronline.net/lists/jdom-interest/2000-July/001587.html
  http://lists.denveronline.net/lists/jdom-interest/2000-July/001600.html

* Consider a "locator" ability for nodes to remember the line number on which
  they were declared, to help debug semantic errors.
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003422.html

--- UNTIED TO A JDOM VERSION ---

* Contribute the samples from Elliotte's XML DevCon talk to the samples/
  directory.  http://metalab.unc.edu/xml/slides/xmlsig/jdom/JDOM.html

* Add a search for jdom.org using Google with site:www.jdom.org, imitating
  http://www.zope.org/SiteIndex/searchForm

* Fix it so check-in messages include diffs.  (jools@jools.org)

* Add ElementLocator to contrib/ directory (from Alfred Lopez)

* Write a guide for contributors
    Follow Sun's coding guidelines, use 4-space (no tab) indents, no lines
    longer than 80 characters

* Consider a builder for a read-only document.  It could "intern" objects to
  reduce memory consumption.  In fact, interning may be good for String
  objects regardless.

* Consider having the license be clear org.jdom is a protected namespace.

--- WILD IDEAS ---

* Figure out if there's a role for a Node interface.  It sounds easy but all 
  attempts so far have hit obstacles.  Amy Lewis talks about it here:
  http://lists.denveronline.net/lists/jdom-interest/2000-December/004016.html

* Consider having element.getChild("foo") use the namespace of the invoked 
  element.  Currently is would be the default namespace.  With this new
  approach you'd pass null to use the default.  This would be more convenient,
  but the downside I see is that it would be inconsistent since 
  new Element("foo") would only create elements in the default namespace.

* Think about somewhat crazy idea of using more inheritance in JDOM to allow
  lightweight but not XML 1.0 complete implementations.  For example Element
  could have a superclass "CommonXMLElement" that supported only what Common 
  XML requires.  Builders could build such elements to be faster and lighter 
  than full elements -- perfect for things like reading config files.  Lots
  of difficulties with this design though.

* Look at Xerces parser features (http://apache.org/xml/features/dom) for
  ideas on things that may be needed.
  http://xml.apache.org/xerces-j/features.html

* Create a JDOM logo.

* Create a Verifier lookup table as an int[256] growable to int[64K] where 
  bits in the returned value indicate that char's ability to be used for a
  task.  So "lookup[(int)'x'] & LETTER_MASK" tells us if it's a letter
  or not.

* Use new Ant regexp task for more efficient JDK 1.1 package renaming.

* Consider methods to return an item's XPath, suggested by 
    Mores Stanislav <stm@prosoft.sk>
  /** Return XPath of this node */ 
  public StringBuffer getXPath(); 
  /** Return XPath of this node relative to given context node. */ 
  public StringBuffer getRelativeXPath(Element ancestor);

* Consider having builders construct nodes that know the line number on which
  they're based.  It's something DOM3 does, and one user requested it.  The
  cost is a heavy price in memory bloat.

* Consider elt.getTreeText() which would recursively get the text (in order) 
  for the subtree, effectively ripping out interveneing Elements.  (Suggested
  by Bob to help with XPath.)

* Shouldn't addNamespaceDeclaration() have a name to match
  getAdditionalNamespaces().

* Consider an HTMLBuilder that reads not-necessarily-well-formed HTML and
  produces a JDOM Document.  The approach I'd suggest is to build on top of
  JTidy first.  That gives a working implementation fast, at the cost of a 
  157K Tidy.jar in the distribution.  After that, perhaps someone would lead 
  an effort to change the JTidy code to build a JDOM Document directly, 
  instead of making a DOM Document or XML stream first.  That would be a lot 
  faster, use less memory, and make our dist smaller.  See
  http://www.sourceforge.net/projects/jtidy for Tidy.

* Look at a (contrib?) outputter option using SAX filters per
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003303.html
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003304.html
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003318.html
  http://lists.denveronline.net/lists/jdom-interest/2000-October/003535.html

* Look at event-based parsing as per the following thread:
  http://lists.denveronline.net/lists/jdom-interest/2000-November/003613.html
  and replies.

* Considering that local vars are considerably faster that instance vars, test
  if using local vars can speed building.

* Consider a builder.setFeature() pass-through method that allows any 
  features to be set that aren't in the http://xml.org namespace.  Make
  those in http://xml.org not to be touched because either we have specific
  requirements for them to be set one way, or we have the feature exposed
  through a Java method.

* Consider Mike Jennings' proposal of two new methods on Element:
  public String getAttributeValue(String name, String default)
  public String getAttributeValue(String name, Namespace ns, String default)
  http://lists.denveronline.net/lists/jdom-interest/2000-December/004155.html

* Figure out a way to set "standalone" in the decl, like doc.setStandalone().
  Probably setStandalone(boolean) and getStandalone().  Maybe we need
  setVersion(String) and getVersion() too.  Perhaps "encoding" should be moved
  into the Document too?  Joe wants it possible to output ignoring the
  standalone flag.

* Consider using a List of instance data so elements only use what they really
  need (saving attrib list, namespace list)

* Consider Element.hasAttributes() and Element.isEmpty()

* Investigate doc.getDescription() to let people add doc descriptions.  It's
  an idea from IBM's parser suggested by andyk.

